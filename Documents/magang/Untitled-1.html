<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ideas - Suitmedia</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <!-- Header -->
    <header class="header" id="header">
        <div class="header-content">
            <a href="#" class="logo">Suitmedia</a>
            <nav>
                <ul class="nav-menu">
                    <li><a href="#" class="nav-link">Work</a></li>
                    <li><a href="#" class="nav-link">About</a></li>
                    <li><a href="#" class="nav-link">Services</a></li>
                    <li><a href="#" class="nav-link active">Ideas</a></li>
                    <li><a href="#" class="nav-link">Careers</a></li>
                    <li><a href="#" class="nav-link">Contact</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- Banner -->
    <section class="banner" id="banner">
        <div class="banner-content">
            <h1 id="bannerTitle">Ideas</h1>
            <p id="bannerSubtitle">Where all our great things begin</p>
        </div>
    </section>

    <!-- Main Content -->
    <main class="main-content">
        <!-- Controls -->
        <div class="controls">
            <div class="page-info" id="pageInfo">
                Showing 1-10 of 100
            </div>
            <div class="control-group">
                <label for="showPerPage">Show per page:</label>
                <select id="showPerPage">
                    <option value="10">10</option>
                    <option value="20">20</option>
                    <option value="50">50</option>
                </select>
                <label for="sortBy">Sort by:</label>
                <select id="sortBy">
                    <option value="-published_at">Newest</option>
                    <option value="published_at">Oldest</option>
                </select>
            </div>
        </div>

        <!-- Posts Grid -->
        <div class="posts-grid" id="postsGrid">
            <!-- Posts will be loaded here -->
        </div>

        <!-- Pagination -->
        <div class="pagination" id="pagination">
            <!-- Pagination will be loaded here -->
        </div>
    </main>

    <!-- API Status Indicator -->
    <div class="api-status" id="apiStatus" style="display: none;">
        Connecting to API...
    </div>

    <!-- Instructions Modal for API Setup -->
    <div id="apiInstructions" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 2000; padding: 20px;">
        <div style="background: white; max-width: 600px; margin: 50px auto; padding: 30px; border-radius: 10px; max-height: 80vh; overflow-y: auto;">
            <h3>API Setup Instructions</h3>
            <p>To use the real Suitmedia API, you need to setup a proxy server because the API requires POST requests with JSON communication.</p>
            
            <h4>Option 1: Browser Extension (Quick Test)</h4>
            <p>Install a CORS extension like "CORS Unblock" or "CORS Everywhere" in your browser.</p>
            
            <h4>Option 2: Node.js Proxy Server</h4>
            <pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto; font-size: 12px;">
const express = require('express');
const cors = require('cors');
const fetch = require('node-fetch');

const app = express();
app.use(cors());
app.use(express.json());

app.post('/api/ideas', async (req, res) => {
    try {
        const response = await fetch('https://suitmedia-backend.suitdev.com/api/ideas', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify(req.body)
        });
        
        const data = await response.json();
        res.json(data);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.listen(3001, () => {
    console.log('Proxy server running on port 3001');
});
            </pre>
            
            <h4>Option 3: PHP Proxy (for shared hosting)</h4>
            <pre style="background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto; font-size: 12px;">
&lt;?php
header('Access-Control-Allow-Origin: *');
header('Access-Control-Allow-Methods: POST');
header('Access-Control-Allow-Headers: Content-Type');
header('Content-Type: application/json');

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $input = json_decode(file_get_contents('php://input'), true);
    
    $ch = curl_init();
    curl_setopt($ch, CURLOPT_URL, 'https://suitmedia-backend.suitdev.com/api/ideas');
    curl_setopt($ch, CURLOPT_POST, true);
    curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($input));
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($ch, CURLOPT_HTTPHEADER, [
        'Content-Type: application/json',
        'Accept: application/json'
    ]);
    
    $response = curl_exec($ch);
    curl_close($ch);
    
    echo $response;
}
?&gt;
            </pre>
            
            <button onclick="document.getElementById('apiInstructions').style.display='none'" style="background: #ff6b35; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; float: right;">Close</button>
            <div style="clear: both;"></div>
        </div>
    </div>

    <script>
        class IdeasPage {
            constructor() {
                this.currentPage = 1;
                this.pageSize = 10;
                this.sortBy = '-published_at';
                this.totalPages = 1;
                this.totalItems = 0;
                this.isLoading = false;
                this.lastScrollY = 0;
                
                this.init();
            }

            init() {
                this.bindEvents();
                this.loadUrlState();
                this.loadPosts();
                this.setupIntersectionObserver();
            }

            bindEvents() {
                // Header scroll behavior
                window.addEventListener('scroll', this.handleScroll.bind(this));
                
                // Controls
                document.getElementById('showPerPage').addEventListener('change', this.handlePageSizeChange.bind(this));
                document.getElementById('sortBy').addEventListener('change', this.handleSortChange.bind(this));
                
                // Parallax effect
                window.addEventListener('scroll', this.handleParallax.bind(this));
                
                // Browser back/forward
                window.addEventListener('popstate', this.handlePopState.bind(this));
            }

            handleScroll() {
                const header = document.getElementById('header');
                const currentScrollY = window.scrollY;
                
                if (currentScrollY > this.lastScrollY && currentScrollY > 100) {
                    header.classList.add('hidden');
                } else if (currentScrollY < this.lastScrollY) {
                    header.classList.remove('hidden');
                }
                
                if (currentScrollY > 50) {
                    header.classList.add('transparent');
                } else {
                    header.classList.remove('transparent');
                }
                
                this.lastScrollY = currentScrollY;
            }

            handleParallax() {
                const scrolled = window.scrollY;
                const parallaxSpeed = 0.5;
                
                const bannerTitle = document.getElementById('bannerTitle');
                const bannerSubtitle = document.getElementById('bannerSubtitle');
                
                if (bannerTitle && bannerSubtitle) {
                    bannerTitle.style.transform = `translateY(${scrolled * parallaxSpeed}px)`;
                    bannerSubtitle.style.transform = `translateY(${scrolled * parallaxSpeed * 0.8}px)`;
                }
            }

            handlePageSizeChange(e) {
                this.pageSize = parseInt(e.target.value);
                this.currentPage = 1;
                this.updateUrl();
                this.loadPosts();
            }

            handleSortChange(e) {
                this.sortBy = e.target.value;
                this.currentPage = 1;
                this.updateUrl();
                this.loadPosts();
            }

            handlePopState() {
                this.loadUrlState();
                this.updateControls();
                this.loadPosts();
            }

            loadUrlState() {
                const urlParams = new URLSearchParams(window.location.search);
                this.currentPage = parseInt(urlParams.get('page')) || 1;
                this.pageSize = parseInt(urlParams.get('size')) || 10;
                this.sortBy = urlParams.get('sort') || '-published_at';
            }

            updateUrl() {
                const params = new URLSearchParams();
                params.set('page', this.currentPage);
                params.set('size', this.pageSize);
                params.set('sort', this.sortBy);
                
                const newUrl = `${window.location.pathname}?${params.toString()}`;
                document.querySelectorAll('.nav-link').forEach(link => {
    if (link.textContent.toLowerCase() === location.pathname.split('/').pop().toLowerCase()) {
        link.classList.add('active');
    }
});
                window.history.pushState({}, '', newUrl);
            }

            updateControls() {
                document.getElementById('showPerPage').value = this.pageSize;
                document.getElementById('sortBy').value = this.sortBy;
            }

            async loadPosts() {
                if (this.isLoading) return;
                
                this.isLoading = true;
                this.showLoading();
                this.showApiStatus('loading', 'Fetching data...');
                
                try {
                    const response = await this.fetchPosts();
                    this.renderPosts(response.data);
                    this.updatePagination(response.meta);
                    this.updatePageInfo(response.meta);
                    
                    // Show success status
                    this.showApiStatus('success', response.fromApi ? 'Real API data loaded' : 'Using simulated data');
                    this.hideApiStatus(3000);
                    
                } catch (error) {
                    console.error('Error loading posts:', error);
                    this.showError();
                    this.showApiStatus('error', 'Failed to load data');
                    this.hideApiStatus(5000);
                } finally {
                    this.isLoading = false;
                }
            }

            async fetchPosts() {
                try {
                    // Try multiple proxy methods (updated for POST requests)
                    const proxyUrls = [
                        // Method 1: CORS Anywhere (supports POST)
                        'https://cors-anywhere.herokuapp.com/',
                        // Method 2: CORS.io proxy (supports POST)
                        'https://cors.io/?',
                        // Method 3: Direct call (if CORS is disabled in browser)
                        '',
                        // Method 4: Alternative proxy
                        'https://api.codetabs.com/v1/proxy/?quest='
                    ];
                    
                    for (let i = 0; i < proxyUrls.length; i++) {
                        try {
                            const response = await this.tryFetchWithProxy(proxyUrls[i]);
                            if (response) return response;
                        } catch (error) {
                            console.log(`Proxy method ${i + 1} failed:`, error.message);
                            continue;
                        }
                    }
                    
                    // If all proxy methods fail, fall back to simulated data
                    console.log('All proxy methods failed, using simulated data');
                    return await this.simulateApiResponse();
                    
                } catch (error) {
                    console.error('Error fetching posts:', error);
                    return await this.simulateApiResponse();
                }
            }

            async tryFetchWithProxy(proxyUrl) {
                const baseUrl = 'https://suitmedia-backend.suitdev.com/api/ideas';
                
                // Prepare JSON payload as per API requirements
                const requestBody = {
                    'page[number]': this.currentPage,
                    'page[size]': this.pageSize,
                    'append[]': ['small_image', 'medium_image'],
                    'sort': this.sortBy
                };
                
                console.log('Request body:', JSON.stringify(requestBody, null, 2));
                
                let requestUrl = baseUrl;
                let fetchOptions = {
                    method: 'POST',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                };
                
                // Handle different proxy methods
                if (proxyUrl === 'https://api.codetabs.com/v1/proxy/?quest=') {
                    // CodeTabs proxy - encode the URL
                    requestUrl = `${proxyUrl}${encodeURIComponent(baseUrl)}`;
                } else if (proxyUrl === 'https://cors-anywhere.herokuapp.com/') {
                    requestUrl = `${proxyUrl}${baseUrl}`;
                    fetchOptions.headers['X-Requested-With'] = 'XMLHttpRequest';
                } else if (proxyUrl === 'https://cors.io/?') {
                    requestUrl = `${proxyUrl}${baseUrl}`;
                } else if (proxyUrl === '') {
                    // Direct API call
                    requestUrl = baseUrl;
                }
                
                console.log('Trying to fetch:', requestUrl);
                console.log('Method:', fetchOptions.method);
                console.log('Headers:', fetchOptions.headers);
                
                const response = await fetch(requestUrl, fetchOptions);
                
                console.log('Response status:', response.status);
                console.log('Response headers:', Object.fromEntries(response.headers.entries()));
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Response error:', errorText);
                    throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                }
                
                let data = await response.json();
                console.log('Response data:', data);
                
                // Transform the response to match our expected format
                if (data && data.data) {
                    return {
                        data: data.data,
                        fromApi: true, // Mark as real API data
                        meta: {
                            pagination: {
                                current_page: data.meta?.pagination?.current_page || this.currentPage,
                                per_page: data.meta?.pagination?.per_page || this.pageSize,
                                total: data.meta?.pagination?.total || data.data.length,
                                total_pages: data.meta?.pagination?.total_pages || Math.ceil((data.meta?.pagination?.total || data.data.length) / this.pageSize)
                            }
                        }
                    };
                }
                
                throw new Error('Invalid response format');
            }

            async simulateApiResponse() {
                // Simulate API delay
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Generate sample data based on current parameters
                const totalItems = 100;
                const totalPages = Math.ceil(totalItems / this.pageSize);
                
                const posts = [];
                const startIndex = (this.currentPage - 1) * this.pageSize;
                
                for (let i = 0; i < this.pageSize && startIndex + i < totalItems; i++) {
                    const index = startIndex + i + 1;
                    posts.push({
                        id: index,
                        title: this.generateTitle(index),
                        published_at: this.generateDate(index),
                        small_image: `https://picsum.photos/300/200?random=${index}`,
                        medium_image: `https://picsum.photos/600/400?random=${index}`
                    });
                }
                
                // Sort posts based on sortBy parameter
                if (this.sortBy === 'published_at') {
                    posts.sort((a, b) => new Date(a.published_at) - new Date(b.published_at));
                } else {
                    posts.sort((a, b) => new Date(b.published_at) - new Date(a.published_at));
                }
                
                return {
                    data: posts,
                    fromApi: false, // Mark as simulated data
                    meta: {
                        pagination: {
                            current_page: this.currentPage,
                            per_page: this.pageSize,
                            total: totalItems,
                            total_pages: totalPages
                        }
                    }
                };
            }

            generateTitle(index) {
                const titles = [
                    'Kunci Tinggalan Influencers Berdasarkan Jumlah Followers',
                    'Jangan Asal Pilih Influencer, Berikut Cara Menentukan Strategi Influencer',
                    'Tips Memilih Influencer yang Tepat untuk Brand Anda',
                    'Strategi Content Marketing untuk Meningkatkan Engagement',
                    'Cara Membangun Brand Awareness melalui Social Media',
                    'Pentingnya Authenticity dalam Influencer Marketing',
                    'Mengoptimalkan ROI dari Kampanye Digital Marketing',
                    'Tren Terbaru dalam Dunia Digital Marketing 2024'
                ];
                
                const title = titles[index % titles.length];
                return index > titles.length ? `${title} - Part ${Math.floor(index / titles.length) + 1}` : title;
            }

            generateDate(index) {
                const date = new Date();
                date.setDate(date.getDate() - index);
                return date.toISOString();
            }

            renderPosts(posts) {
                const grid = document.getElementById('postsGrid');
                grid.innerHTML = '';
                
                posts.forEach(post => {
                    const card = this.createPostCard(post);
                    grid.appendChild(card);
                });
            }

            createPostCard(post) {
                const card = document.createElement('div');
                card.className = 'post-card';
                
                const publishedDate = new Date(post.published_at).toLocaleDateString('en-US', {
                    day: 'numeric',
                    month: 'long',
                    year: 'numeric'
                });
                
                // Handle both simulated and real API image URLs
                const imageUrl = post.small_image || post.medium_image || `https://picsum.photos/300/200?random=${post.id}`;
                
                card.innerHTML = `
                    <div class="post-thumbnail">
                        <img src="${imageUrl}" alt="${post.title}" loading="lazy" class="post-image">
                    </div>
                    <div class="post-content">
                        <div class="post-date">${publishedDate}</div>
                        <h3 class="post-title">${post.title}</h3>
                    </div>
                `;
                
                return card;
            }

            updatePagination(meta) {
                const pagination = document.getElementById('pagination');
                pagination.innerHTML = '';
                
                const { current_page, total_pages } = meta.pagination;
                this.totalPages = total_pages;
                
                // Previous button
                const prevBtn = document.createElement('button');
                prevBtn.textContent = '← Previous';
                prevBtn.disabled = current_page === 1;
                prevBtn.addEventListener('click', () => this.goToPage(current_page - 1));
                pagination.appendChild(prevBtn);
                
                // Page numbers
                const startPage = Math.max(1, current_page - 2);
                const endPage = Math.min(total_pages, current_page + 2);
                
                if (startPage > 1) {
                    const firstBtn = document.createElement('button');
                    firstBtn.textContent = '1';
                    firstBtn.addEventListener('click', () => this.goToPage(1));
                    pagination.appendChild(firstBtn);
                    
                    if (startPage > 2) {
                        const ellipsis = document.createElement('span');
                        ellipsis.textContent = '...';
                        pagination.appendChild(ellipsis);
                    }
                }
                
                for (let i = startPage; i <= endPage; i++) {
                    const pageBtn = document.createElement('button');
                    pageBtn.textContent = i;
                    pageBtn.className = i === current_page ? 'active' : '';
                    pageBtn.addEventListener('click', () => this.goToPage(i));
                    pagination.appendChild(pageBtn);
                }
                
                if (endPage < total_pages) {
                    if (endPage < total_pages - 1) {
                        const ellipsis = document.createElement('span');
                        ellipsis.textContent = '...';
                        pagination.appendChild(ellipsis);
                    }
                    
                    const lastBtn = document.createElement('button');
                    lastBtn.textContent = total_pages;
                    lastBtn.addEventListener('click', () => this.goToPage(total_pages));
                    pagination.appendChild(lastBtn);
                }
                
                // Next button
                const nextBtn = document.createElement('button');
                nextBtn.textContent = 'Next →';
                nextBtn.disabled = current_page === total_pages;
                nextBtn.addEventListener('click', () => this.goToPage(current_page + 1));
                pagination.appendChild(nextBtn);
            }

            updatePageInfo(meta) {
                const { current_page, per_page, total } = meta.pagination;
                const start = (current_page - 1) * per_page + 1;
                const end = Math.min(current_page * per_page, total);
                
                document.getElementById('pageInfo').textContent = `Showing ${start}-${end} of ${total}`;
            }

            goToPage(page) {
                if (page >= 1 && page <= this.totalPages && page !== this.currentPage) {
                    this.currentPage = page;
                    this.updateUrl();
                    this.loadPosts();
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
            }

            showLoading() {
                const grid = document.getElementById('postsGrid');
                grid.innerHTML = '<div class="loading">Loading posts...</div>';
            }

            showError() {
                const grid = document.getElementById('postsGrid');
                grid.innerHTML = '<div class="loading">Error loading posts. Please try again.</div>';
            }

            showApiStatus(type, message) {
                const status = document.getElementById('apiStatus');
                status.className = `api-status ${type}`;
                status.textContent = message;
                status.style.display = 'block';
                
                // Show API instructions if all methods failed
                if (type === 'error' && message.includes('Failed to load data')) {
                    status.innerHTML = `
                        ${message}<br>
                        <button onclick="document.getElementById('apiInstructions').style.display='block'" 
                                style="background: #fff; color: #333; padding: 5px 10px; border: none; border-radius: 3px; cursor: pointer; margin-top: 5px; font-size: 11px;">
                            Show API Setup Instructions
                        </button>
                    `;
                }
            }

            hideApiStatus(delay = 0) {
                setTimeout(() => {
                    const status = document.getElementById('apiStatus');
                    status.style.display = 'none';
                }, delay);
            }

            setupIntersectionObserver() {
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const img = entry.target;
                            img.classList.remove('loading');
                            observer.unobserve(img);
                        }
                    });
                });

                // Observe images as they're added to the page
                const gridObserver = new MutationObserver((mutations) => {
                    mutations.forEach(mutation => {
                        mutation.addedNodes.forEach(node => {
                            if (node.nodeType === 1 && node.querySelector) {
                                const images = node.querySelectorAll('img[loading="lazy"]');
                                images.forEach(img => {
                                    img.classList.add('loading');
                                    observer.observe(img);
                                });
                            }
                        });
                    });
                });

                gridObserver.observe(document.getElementById('postsGrid'), {
                    childList: true,
                    subtree: true
                });
            }
        }

        // Initialize the page
        document.addEventListener('DOMContentLoaded', () => {
            new IdeasPage();
        });
    </script>
</body>
</html>